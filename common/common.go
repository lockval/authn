package common

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"log"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	clientv3 "go.etcd.io/etcd/client/v3"
)

const (
	// SchemaProxy SchemaProxy
	SchemaProxy = "proxy"
)

var (
	etcds       = flag.String("etcds", "http://127.0.0.1:2379", "http://etcd1:2379;http://etcd2:2379;http://etcd3:2379@user:pass")
	VSecretkey  = flag.String("verifySecretkey", "gxG3Vq9cnB86", "verify secret key")
	ServiceAddr = flag.String("serviceAddr", "", "ip:port")

	EtcdCli *clientv3.Client = nil
)

// Platform This json is generated by the platform authentication server
// and passed to the login server for login
type Platform struct {
	PID            string  `json:"PID"`            // Platform ID
	Info           *string `json:"Info"`           // login info
	Token          string  `json:"Token"`          // Token=sha256(TimestampMicro+PID+Platform+Info+verifySecretkey)
	Platform       string  `json:"Platform"`       // Platform name
	TimestampMicro int64   `json:"TimestampMicro"` // timestamp
}

// LoginByLoginOrPlatform The user will log in using Login or Platform authentication information,
// and will return LoginRequ2ws if successful
type LoginByLoginOrPlatform struct {

	// Login server
	UID     string `json:"UID"`     // user ID
	DBToken string `json:"DBToken"` // user token

	// Platform server
	PID            string  `json:"PID"`            // Platform ID
	Info           *string `json:"Info"`           // login info
	Token          string  `json:"Token"`          // Token=sha256(TimestampMicro+PID+Platform+Info+verifySecretkey)
	Platform       string  `json:"Platform"`       // Platform name
	TimestampMicro int64   `json:"TimestampMicro"` // timestamp

}

// LoginRequ2ws This json is transparently passed to the gateway.
// So you can design an authentication server not associated with the gateway.
type LoginRequ2ws struct {
	UID     string `json:"UID"`     // user ID, In WATCH mode this is the ID of the watch
	DBToken string `json:"DBToken"` // Login with DBToken

	Info           string   `json:"Info"`           // login info
	Token          string   `json:"Token"`          // Token=sha256(TimestampMicro+UID+DBToken+Info+verifySecretkey)
	TimestampMicro int64    `json:"TimestampMicro"` // timestamp
	Keeps          []string `json:"Keeps"`          // some connects that was kept
}

// GetHash sha256=64len md5=32len sha1=40len
func GetHash(text string) string {
	h := sha256.New()
	_, _ = h.Write([]byte(text))

	return hex.EncodeToString(h.Sum(nil))
}

// EtcdInit init etcd
func EtcdInit() {
	if EtcdCli != nil {
		return
	}

	log.Println("start connect etcd:", *etcds)

	urlsUserpass := strings.Split(*etcds, "@")
	var user, pass string
	if len(urlsUserpass) > 1 {
		up := strings.Split(urlsUserpass[1], ":")
		user = up[0]
		if len(up) > 1 {
			pass = up[1]
		}
	}

	var err error
	EtcdCli, err = clientv3.New(clientv3.Config{
		Endpoints:   strings.Split(urlsUserpass[0], ";"),
		DialTimeout: 15 * time.Second,
		Username:    user,
		Password:    pass,
	})
	if err != nil {
		log.Fatal("clientv3.New")
	}

reConnect:
	_, err = EtcdCli.Get(context.Background(), "?")
	if err != nil {
		if strings.Contains(err.Error(), "refused") {
			time.Sleep(time.Second)
			goto reConnect
		}
		log.Fatal("EtcdCli.Get")
	}

}

// Reg2etcd Regregister to gateway: /proxy/authname/
func Reg2etcd(addr, authname string) {
	log.Println("Reg2etcd", authname, addr)

	_, err := EtcdCli.Put(context.Background(), "/"+SchemaProxy+"/"+authname, addr)
	if err != nil {
		panic(err)
	}
}

// HandleExit handle exit signal
func HandleExit(exitProc func()) {
	ch := make(chan os.Signal, 1)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGHUP, syscall.SIGTERM)

	sig := <-ch
	switch sig {
	default:
		log.Println("HandleExit other sig:", sig.String())

	case syscall.SIGINT:
		log.Println("HandleExit SIGINT")
		exitProc()
	case syscall.SIGQUIT:
		log.Println("HandleExit SIGQUIT")
		exitProc()
	case syscall.SIGHUP:
		log.Println("HandleExit SIGHUP")
		exitProc()
	case syscall.SIGTERM:
		log.Println("HandleExit SIGTERM")
		exitProc()
	}

	os.Exit(1)
}
